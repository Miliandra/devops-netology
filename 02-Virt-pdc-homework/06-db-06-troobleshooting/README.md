1. Для поиска `opid` воспользуемся таким запросом:
```
use admin
db.aggregate( [
   { $currentOp : { allUsers: true, localOps: true } },
   { $match : {op: "secs_running" : { "$gt" : 180 } }} // Optional.  Specify the condition to find the op.
													// e.g. { "op" : "update", "ns": "mydb.someCollection" }
] )
```
С помощью опции `secs_running` найдем все активные операции, выполняющиеся дольше 180 секунд.\
После нахождения нужного `opid`, воспользуемся таким запросом и убьем его:
```
db.killOp(<opid of the query to kill>)
```
Для решения проблемы с долгими запросами(зависшими), можно добавить опцию `maxTimeMS` - которая установит ограничение по времени в n миллисекунд для операции:
```
db.runCommand( { distinct: "collection",
                 key: "city",
                 maxTimeMS: 45 } )
```
2. Вероятно мы столкнулись с проблемой нехватки ресурсов при создании форков(Отталкиваясь от официальной документации), а тут стоит задать вопрос, а где у нас развернут `Redis`:
	- Если `Redis` развернут на ВМ, то нам надо уточнить в чем проблема, либо нехватки RAM, либо проблема с дисковой подсистемой, а также возможна проблема с сетью, но в случае виртуально инфраструктуры это почти исключено, если только проблемы не наблюдаются непосредственно на хосте виртуализации;
	- Если `Redis` развернут на железе, то тут немного все проще, у нас слабое железо и для данных операций его нужно обновить;
3. Данная ошибка может возникнуть по нескольким причинам:
	- Проблемы с сетевой доступностью;
	- Запрос не уложился в `net_read_timeout`;
	- Тайм-аут по подключению `connect_timeout`;
Тогда мы смотрим лог ошибок и можем сделать следующее:
	- Увеличить параметр `max_allowed_packet`;
	- Так как происходит запрос, то вероятно, запрос очень ресурсоемкий и его стоит разбить на более мелкие и проанализировать их;
	- Так же может помочь увеличение ресурсов сервера/ВМ, где находится база;
4. Из-за нехватки памяти мы столкнулись с такой проблемой, но `PostgreSQL` может быть не единственным виновником данного события:
	- Так же такое могло произойти из-за утечки памяти и поэтому наш процесс был убит `oom-killer`, если на сервере с БД находился не только `PostgreSQL`;
	- Возможно так же проблема с зависшими запросами к базе, либо очень тяжеловесными запросами, которые нагрузили нашу базу;\

        Решение данной проблемы - это увеличение памяти, а так же наблюдение за транзакциями и запросами к базам(особенно если они выполняются человеком).\
        Можно еще добавить `vm.overcommit_memory = 2` чтобы не обрабатывать запросы, которые превышает суммарный размер памяти пространства `swap` и `ram`.
